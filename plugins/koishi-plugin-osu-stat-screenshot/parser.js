module.exports = // Generated by Peggy 1.2.0.
//
// https://peggyjs.org/
(function () {
  'use strict'

  function _rawCommand (server, command) {
  	return { server, ...command }
  }

  function peg$subclass (child, parent) {
    function C () { this.constructor = child }
    C.prototype = parent.prototype
    child.prototype = new C()
  }

  function peg$SyntaxError (message, expected, found, location) {
    const self = Error.call(this, message)
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(self, peg$SyntaxError.prototype)
    }
    self.expected = expected
    self.found = found
    self.location = location
    self.name = 'SyntaxError'
    return self
  }

  peg$subclass(peg$SyntaxError, Error)

  function peg$padEnd (str, targetLength, padString) {
    padString = padString || ' '
    if (str.length > targetLength) { return str }
    targetLength -= str.length
    padString += padString.repeat(targetLength)
    return str + padString.slice(0, targetLength)
  }

  peg$SyntaxError.prototype.format = function (sources) {
    let str = 'Error: ' + this.message
    if (this.location) {
      let src = null
      let k
      for (k = 0; k < sources.length; k++) {
        if (sources[k].source === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g)
          break
        }
      }
      const s = this.location.start
      const loc = this.location.source + ':' + s.line + ':' + s.column
      if (src) {
        const e = this.location.end
        const filler = peg$padEnd('', s.line.toString().length, ' ')
        const line = src[s.line - 1]
        const last = s.line === e.line ? e.column : line.length + 1
        str += '\n --> ' + loc + '\n' +
            filler + ' |\n' +
            s.line + ' | ' + line + '\n' +
            filler + ' | ' + peg$padEnd('', s.column - 1, ' ') +
            peg$padEnd('', last - s.column, '^')
      } else {
        str += '\n at ' + loc
      }
    }
    return str
  }

  peg$SyntaxError.buildMessage = function (expected, found) {
    const DESCRIBE_EXPECTATION_FNS = {
      literal: function (expectation) {
        return '"' + literalEscape(expectation.text) + '"'
      },

      class: function (expectation) {
        const escapedParts = expectation.parts.map(function (part) {
          return Array.isArray(part)
            ? classEscape(part[0]) + '-' + classEscape(part[1])
            : classEscape(part)
        })

        return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']'
      },

      any: function () {
        return 'any character'
      },

      end: function () {
        return 'end of input'
      },

      other: function (expectation) {
        return expectation.description
      }
    }

    function hex (ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase()
    }

    function literalEscape (s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch) })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch) })
    }

    function classEscape (s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g, '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch) })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch) })
    }

    function describeExpectation (expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation)
    }

    function describeExpected (expected) {
      const descriptions = expected.map(describeExpectation)
      let i, j

      descriptions.sort()

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i]
            j++
          }
        }
        descriptions.length = j
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0]

        case 2:
          return descriptions[0] + ' or ' + descriptions[1]

        default:
          return descriptions.slice(0, -1).join(', ') +
            ', or ' +
            descriptions[descriptions.length - 1]
      }
    }

    function describeFound (found) {
      return found ? '"' + literalEscape(found) + '"' : 'end of input'
    }

    return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.'
  }

  function peg$parse (input, options) {
    options = options !== undefined ? options : {}

    const peg$FAILED = {}
    const peg$source = options.grammarSource

    const peg$startRuleFunctions = { Root: peg$parseRoot }
    let peg$startRuleFunction = peg$parseRoot

    const peg$c0 = '?'
    const peg$c1 = '!!'
    const peg$c2 = '*'
    const peg$c3 = '#'
    const peg$c4 = 'userpage'
    const peg$c5 = 'stat'
    const peg$c6 = 'recent'
    const peg$c7 = 'pr'
    const peg$c8 = 'score'
    const peg$c9 = 'best'
    const peg$c10 = 'bp'
    const peg$c11 = '@last'
    const peg$c12 = '@'
    const peg$c13 = 'from'
    const peg$c14 = ':'
    const peg$c15 = 'to'
    const peg$c16 = 'setuser'
    const peg$c17 = 'setmode'
    const peg$c18 = '\t'
    const peg$c19 = '\v'
    const peg$c20 = '\f'
    const peg$c21 = ' '
    const peg$c22 = '\xA0'
    const peg$c23 = '\uFEFF'
    const peg$c24 = '\n'
    const peg$c25 = '\r\n'
    const peg$c26 = '\r'
    const peg$c27 = '\u2028'
    const peg$c28 = '\u2029'
    const peg$c29 = '/*'
    const peg$c30 = '*/'
    const peg$c31 = '//'

    const peg$r0 = /^[a-zA-Z]/
    const peg$r1 = /^[0-9]/
    const peg$r2 = /^[\-\/|]/
    const peg$r3 = /^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/
    const peg$r4 = /^[\n\r\u2028\u2029]/

    const peg$e0 = peg$otherExpectation('\xAB')
    const peg$e1 = peg$otherExpectation('username')
    const peg$e2 = peg$anyExpectation()
    const peg$e3 = peg$otherExpectation('command')
    const peg$e4 = peg$otherExpectation('bancho server')
    const peg$e5 = peg$literalExpectation('?', false)
    const peg$e6 = peg$literalExpectation('!!', false)
    const peg$e7 = peg$otherExpectation('ppy.sb server')
    const peg$e8 = peg$literalExpectation('*', false)
    const peg$e9 = peg$otherExpectation('mode')
    const peg$e10 = peg$classExpectation([['a', 'z'], ['A', 'Z']], false, false)
    const peg$e11 = peg$otherExpectation(':mode')
    const peg$e12 = peg$literalExpectation('#', false)
    const peg$e13 = peg$literalExpectation('userpage', true)
    const peg$e14 = peg$otherExpectation('stat')
    const peg$e15 = peg$literalExpectation('stat', true)
    const peg$e16 = peg$otherExpectation('recent')
    const peg$e17 = peg$literalExpectation('recent', true)
    const peg$e18 = peg$literalExpectation('pr', true)
    const peg$e19 = peg$otherExpectation('score')
    const peg$e20 = peg$literalExpectation('score', true)
    const peg$e21 = peg$literalExpectation('best', true)
    const peg$e22 = peg$literalExpectation('bp', true)
    const peg$e23 = peg$literalExpectation('@last', false)
    const peg$e24 = peg$literalExpectation('@', false)
    const peg$e25 = peg$literalExpectation('from', true)
    const peg$e26 = peg$literalExpectation(':', false)
    const peg$e27 = peg$literalExpectation('to', true)
    const peg$e28 = peg$literalExpectation('setUser', true)
    const peg$e29 = peg$literalExpectation('setMode', true)
    const peg$e30 = peg$otherExpectation('digit')
    const peg$e31 = peg$classExpectation([['0', '9']], false, false)
    const peg$e32 = peg$otherExpectation('integer')
    const peg$e33 = peg$otherExpectation('year')
    const peg$e34 = peg$otherExpectation('month')
    const peg$e35 = peg$otherExpectation('day')
    const peg$e36 = peg$otherExpectation('date')
    const peg$e37 = peg$classExpectation(['-', '/', '|'], false, false)
    const peg$e38 = peg$classExpectation([' ', '\xA0', '\u1680', ['\u2000', '\u200A'], '\u202F', '\u205F', '\u3000'], false, false)
    const peg$e39 = peg$otherExpectation('whitespace')
    const peg$e40 = peg$literalExpectation('\t', false)
    const peg$e41 = peg$literalExpectation('\v', false)
    const peg$e42 = peg$literalExpectation('\f', false)
    const peg$e43 = peg$literalExpectation(' ', false)
    const peg$e44 = peg$literalExpectation('\xA0', false)
    const peg$e45 = peg$literalExpectation('\uFEFF', false)
    const peg$e46 = peg$classExpectation(['\n', '\r', '\u2028', '\u2029'], false, false)
    const peg$e47 = peg$otherExpectation('end of line')
    const peg$e48 = peg$literalExpectation('\n', false)
    const peg$e49 = peg$literalExpectation('\r\n', false)
    const peg$e50 = peg$literalExpectation('\r', false)
    const peg$e51 = peg$literalExpectation('\u2028', false)
    const peg$e52 = peg$literalExpectation('\u2029', false)
    const peg$e53 = peg$otherExpectation('comment')
    const peg$e54 = peg$literalExpectation('/*', false)
    const peg$e55 = peg$literalExpectation('*/', false)
    const peg$e56 = peg$literalExpectation('//', false)

    const peg$f0 = function (lines) { return lines.filter(line => !line.comment) }
    const peg$f1 = function (comment) { return { comment } }
    const peg$f2 = function (line) { return line }
    const peg$f3 = function (username) { return username.join('').trim() }
    const peg$f4 = function (command) { return _rawCommand('bancho', command) }
    const peg$f5 = function (command) { return _rawCommand('sb', command) }
    const peg$f6 = function (q, user) { return { ...q, user } }
    const peg$f7 = function (q, id) { return { ...q, id } }
    const peg$f8 = function (q, user) { return { ...q, user } }
    const peg$f9 = function (q, mode) { return { ...q, mode } }
    const peg$f10 = function (m) { return m.join('') }
    const peg$f11 = function () { return { type: 'userpage' } }
    const peg$f12 = function (mode) { return { type: 'stat', mode } }
    const peg$f13 = function (mode) { return { type: 'recent-score', mode } }
    const peg$f14 = function (mode) { return { type: 'score', mode } }
    const peg$f15 = function (id) { return { id } }
    const peg$f16 = function (last) { return { last } }
    const peg$f17 = function (dates) {
      return {
        date: dates.reduce((acc, cur) => {
          if (cur.from) {
            acc.from = cur.from
          } else if (cur.to) {
            acc.to = cur.to
          }
          return acc
        }, {})
      }
    }
    const peg$f18 = function (find) {
      return {
        type: 'best',
    	  find
      }
    }
    const peg$f19 = function (hours) { return hours }
    const peg$f20 = function (date) { return date }
    const peg$f21 = function (d) { return { from: d } }
    const peg$f22 = function (d) { return { to: d } }
    const peg$f23 = function () { return { type: 'set-user' } }
    const peg$f24 = function () { return { type: 'set-mode' } }
    const peg$f25 = function (id) { return parseInt(id.join('')) }
    const peg$f26 = function (year) { return parseInt(year.join('')) }
    const peg$f27 = function (m) {
      if (m.length == 1) return parseInt(m[0])
      // else if (!m.length) throw new Error("Invalid month")
      else {
        m = parseInt(m.join(''))
        if (m > 12) throw new Error('Invalid month')
        return m
      }
    }
    const peg$f28 = function (m) {
      if (m.length == 1) return parseInt(m[0])
      // else if (!m.length) throw new Error("Invalid month")
      else {
        m = parseInt(m.join(''))
        if (m > 31) throw new Error('Invalid day')
        return m
      }
    }
    const peg$f29 = function (year, month, day) {
      	return { year, month, day }
    }

    let peg$currPos = 0
    let peg$savedPos = 0
    const peg$posDetailsCache = [{ line: 1, column: 1 }]
    let peg$maxFailPos = 0
    let peg$maxFailExpected = []
    let peg$silentFails = 0

    let peg$result

    if ('startRule' in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + '".')
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule]
    }

    function text () {
      return input.substring(peg$savedPos, peg$currPos)
    }

    function offset () {
      return peg$savedPos
    }

    function range () {
      return {
        source: peg$source,
        start: peg$savedPos,
        end: peg$currPos
      }
    }

    function location () {
      return peg$computeLocation(peg$savedPos, peg$currPos)
    }

    function expected (description, location) {
      location = location !== undefined
        ? location
        : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      )
    }

    function error (message, location) {
      location = location !== undefined
        ? location
        : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location)
    }

    function peg$literalExpectation (text, ignoreCase) {
      return { type: 'literal', text: text, ignoreCase: ignoreCase }
    }

    function peg$classExpectation (parts, inverted, ignoreCase) {
      return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase }
    }

    function peg$anyExpectation () {
      return { type: 'any' }
    }

    function peg$endExpectation () {
      return { type: 'end' }
    }

    function peg$otherExpectation (description) {
      return { type: 'other', description: description }
    }

    function peg$computePosDetails (pos) {
      let details = peg$posDetailsCache[pos]
      let p

      if (details) {
        return details
      } else {
        p = pos - 1
        while (!peg$posDetailsCache[p]) {
          p--
        }

        details = peg$posDetailsCache[p]
        details = {
          line: details.line,
          column: details.column
        }

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++
            details.column = 1
          } else {
            details.column++
          }

          p++
        }

        peg$posDetailsCache[pos] = details

        return details
      }
    }

    function peg$computeLocation (startPos, endPos) {
      const startPosDetails = peg$computePosDetails(startPos)
      const endPosDetails = peg$computePosDetails(endPos)

      return {
        source: peg$source,
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      }
    }

    function peg$fail (expected) {
      if (peg$currPos < peg$maxFailPos) { return }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos
        peg$maxFailExpected = []
      }

      peg$maxFailExpected.push(expected)
    }

    function peg$buildSimpleError (message, location) {
      return new peg$SyntaxError(message, null, null, location)
    }

    function peg$buildStructuredError (expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      )
    }

    function peg$parseRoot () {
      let s0, s1, s2

      s0 = peg$currPos
      s1 = []
      s2 = peg$parseExpression()
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseExpression()
        }
      } else {
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f0(s1)
      }
      s0 = s1

      return s0
    }

    function peg$parseExpression () {
      let s0, s1, s2, s3

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$parse_()
      s2 = peg$currPos
      s3 = peg$parseCommand()
      if (s3 !== peg$FAILED) {
        s2 = s3
      } else {
        peg$currPos = s2
        s2 = peg$FAILED
      }
      if (s2 === peg$FAILED) {
        s2 = peg$currPos
        s3 = peg$parseComment()
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2
          s3 = peg$f1(s3)
        }
        s2 = s3
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_()
        peg$savedPos = s0
        s0 = peg$f2(s2)
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e0) }
      }

      return s0
    }

    function peg$parseUsername () {
      let s0, s1, s2, s3, s4

      peg$silentFails++
      s0 = peg$currPos
      s1 = []
      s2 = peg$currPos
      s3 = peg$currPos
      peg$silentFails++
      s4 = peg$parseLineTerminatorSequence()
      peg$silentFails--
      if (s4 === peg$FAILED) {
        s3 = undefined
      } else {
        peg$currPos = s3
        s3 = peg$FAILED
      }
      if (s3 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s4 = input.charAt(peg$currPos)
          peg$currPos++
        } else {
          s4 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e2) }
        }
        if (s4 !== peg$FAILED) {
          s2 = s4
        } else {
          peg$currPos = s2
          s2 = peg$FAILED
        }
      } else {
        peg$currPos = s2
        s2 = peg$FAILED
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$currPos
          s3 = peg$currPos
          peg$silentFails++
          s4 = peg$parseLineTerminatorSequence()
          peg$silentFails--
          if (s4 === peg$FAILED) {
            s3 = undefined
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
          if (s3 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos)
              peg$currPos++
            } else {
              s4 = peg$FAILED
              if (peg$silentFails === 0) { peg$fail(peg$e2) }
            }
            if (s4 !== peg$FAILED) {
              s2 = s4
            } else {
              peg$currPos = s2
              s2 = peg$FAILED
            }
          } else {
            peg$currPos = s2
            s2 = peg$FAILED
          }
        }
      } else {
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f3(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e1) }
      }

      return s0
    }

    function peg$parseCommand () {
      let s0, s1

      peg$silentFails++
      s0 = peg$parseBanchoCommand()
      if (s0 === peg$FAILED) {
        s0 = peg$parseSBCommand()
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e3) }
      }

      return s0
    }

    function peg$parseBanchoCommand () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.charCodeAt(peg$currPos) === 63) {
        s1 = peg$c0
        peg$currPos++
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e5) }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c1) {
          s1 = peg$c1
          peg$currPos += 2
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e6) }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseBaseCommand()
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0
          s0 = peg$f4(s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e4) }
      }

      return s0
    }

    function peg$parseSBCommand () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c2
        peg$currPos++
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e8) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseBaseCommand()
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0
          s0 = peg$f5(s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e7) }
      }

      return s0
    }

    function peg$parseBaseCommand () {
      let s0, s1, s2, s3

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$parseStatCommand()
      if (s1 === peg$FAILED) {
        s1 = peg$parseRecentCommand()
        if (s1 === peg$FAILED) {
          s1 = peg$parseBestScoresCommand()
          if (s1 === peg$FAILED) {
            s1 = peg$parseUserpageCommand()
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesp()
        if (s2 !== peg$FAILED) {
          s3 = peg$parseUsername()
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f6(s1, s3)
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos
        s1 = peg$parseScoreCommand()
        if (s1 !== peg$FAILED) {
          s2 = peg$parsesp()
          if (s2 !== peg$FAILED) {
            s3 = peg$parseInt()
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0
              s0 = peg$f7(s1, s3)
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos
          s1 = peg$parseBindUserCommand()
          if (s1 !== peg$FAILED) {
            s2 = peg$parsesp()
            if (s2 !== peg$FAILED) {
              s3 = peg$parseUsername()
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f8(s1, s3)
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos
            s1 = peg$parseBindModeCommand()
            if (s1 !== peg$FAILED) {
              s2 = peg$parsesp()
              if (s2 !== peg$FAILED) {
                s3 = peg$parseMode()
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0
                  s0 = peg$f9(s1, s3)
                } else {
                  peg$currPos = s0
                  s0 = peg$FAILED
                }
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          }
        }
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e3) }
      }

      return s0
    }

    function peg$parseMode () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      s1 = []
      if (peg$r0.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s2 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e10) }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2)
          if (peg$r0.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos)
            peg$currPos++
          } else {
            s2 = peg$FAILED
            if (peg$silentFails === 0) { peg$fail(peg$e10) }
          }
        }
      } else {
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f10(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e9) }
      }

      return s0
    }

    function peg$parseHashtagMode () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c3
        peg$currPos++
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e12) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseMode()
        if (s2 !== peg$FAILED) {
          s0 = s2
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e11) }
      }

      return s0
    }

    function peg$parseUserpageCommand () {
      let s0, s1

      s0 = peg$currPos
      if (input.substr(peg$currPos, 8).toLowerCase() === peg$c4) {
        s1 = input.substr(peg$currPos, 8)
        peg$currPos += 8
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e13) }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f11()
      }
      s0 = s1

      return s0
    }

    function peg$parseStatCommand () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c5) {
        s1 = input.substr(peg$currPos, 4)
        peg$currPos += 4
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e15) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHashtagMode()
        if (s2 === peg$FAILED) {
          s2 = null
        }
        peg$savedPos = s0
        s0 = peg$f12(s2)
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e14) }
      }

      return s0
    }

    function peg$parseRecentCommand () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c6) {
        s1 = input.substr(peg$currPos, 6)
        peg$currPos += 6
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e17) }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c7) {
          s1 = input.substr(peg$currPos, 2)
          peg$currPos += 2
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e18) }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHashtagMode()
        if (s2 === peg$FAILED) {
          s2 = null
        }
        peg$savedPos = s0
        s0 = peg$f13(s2)
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e16) }
      }

      return s0
    }

    function peg$parseScoreCommand () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c8) {
        s1 = input.substr(peg$currPos, 5)
        peg$currPos += 5
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e20) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseHashtagMode()
        if (s2 === peg$FAILED) {
          s2 = null
        }
        peg$savedPos = s0
        s0 = peg$f14(s2)
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e19) }
      }

      return s0
    }

    function peg$parseBestScoresCommand () {
      let s0, s1, s2, s3, s4, s5, s6

      s0 = peg$currPos
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c9) {
        s1 = input.substr(peg$currPos, 4)
        peg$currPos += 4
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e21) }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 2).toLowerCase() === peg$c10) {
          s1 = input.substr(peg$currPos, 2)
          peg$currPos += 2
        } else {
          s1 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e22) }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos
        s3 = peg$parseInt()
        if (s3 !== peg$FAILED) {
          peg$savedPos = s2
          s3 = peg$f15(s3)
        }
        s2 = s3
        if (s2 === peg$FAILED) {
          s2 = peg$currPos
          s3 = peg$parsesp()
          if (s3 !== peg$FAILED) {
            s4 = peg$parseLast()
            if (s4 !== peg$FAILED) {
              peg$savedPos = s2
              s2 = peg$f16(s4)
            } else {
              peg$currPos = s2
              s2 = peg$FAILED
            }
          } else {
            peg$currPos = s2
            s2 = peg$FAILED
          }
          if (s2 === peg$FAILED) {
            s2 = peg$currPos
            s3 = []
            s4 = peg$currPos
            s5 = peg$parsesp()
            if (s5 !== peg$FAILED) {
              s6 = peg$parseDateCommand()
              if (s6 !== peg$FAILED) {
                s4 = s6
              } else {
                peg$currPos = s4
                s4 = peg$FAILED
              }
            } else {
              peg$currPos = s4
              s4 = peg$FAILED
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4)
                s4 = peg$currPos
                s5 = peg$parsesp()
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseDateCommand()
                  if (s6 !== peg$FAILED) {
                    s4 = s6
                  } else {
                    peg$currPos = s4
                    s4 = peg$FAILED
                  }
                } else {
                  peg$currPos = s4
                  s4 = peg$FAILED
                }
              }
            } else {
              s3 = peg$FAILED
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s2
              s3 = peg$f17(s3)
            }
            s2 = s3
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0
          s0 = peg$f18(s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseLast () {
      let s0, s1, s2, s3

      s0 = peg$currPos
      if (input.substr(peg$currPos, 5) === peg$c11) {
        s1 = peg$c11
        peg$currPos += 5
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e23) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesp()
        if (s2 !== peg$FAILED) {
          s3 = peg$parseInt()
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f19(s3)
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseDateCommand () {
      let s0, s1, s2

      s0 = peg$currPos
      if (input.charCodeAt(peg$currPos) === 64) {
        s1 = peg$c12
        peg$currPos++
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e24) }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDateFromCommand()
        if (s2 === peg$FAILED) {
          s2 = peg$parseDateToCommand()
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0
          s0 = peg$f20(s2)
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseDateFromCommand () {
      let s0, s1, s2, s3, s4

      s0 = peg$currPos
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c13) {
        s1 = input.substr(peg$currPos, 4)
        peg$currPos += 4
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e25) }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c14
          peg$currPos++
        } else {
          s2 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e26) }
        }
        if (s2 === peg$FAILED) {
          s2 = null
        }
        s3 = peg$parsesp()
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDate()
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f21(s4)
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseDateToCommand () {
      let s0, s1, s2, s3, s4

      s0 = peg$currPos
      if (input.substr(peg$currPos, 2).toLowerCase() === peg$c15) {
        s1 = input.substr(peg$currPos, 2)
        peg$currPos += 2
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e27) }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c14
          peg$currPos++
        } else {
          s2 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e26) }
        }
        if (s2 === peg$FAILED) {
          s2 = null
        }
        s3 = peg$parsesp()
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDate()
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0
            s0 = peg$f22(s4)
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseBindUserCommand () {
      let s0, s1

      s0 = peg$currPos
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c16) {
        s1 = input.substr(peg$currPos, 7)
        peg$currPos += 7
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e28) }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f23()
      }
      s0 = s1

      return s0
    }

    function peg$parseBindModeCommand () {
      let s0, s1

      s0 = peg$currPos
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c17) {
        s1 = input.substr(peg$currPos, 7)
        peg$currPos += 7
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e29) }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f24()
      }
      s0 = s1

      return s0
    }

    function peg$parseDigit () {
      let s0, s1

      peg$silentFails++
      if (peg$r1.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e31) }
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e30) }
      }

      return s0
    }

    function peg$parseInt () {
      let s0, s1, s2

      peg$silentFails++
      s0 = peg$currPos
      s1 = []
      s2 = peg$parseDigit()
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2)
          s2 = peg$parseDigit()
        }
      } else {
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f25(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e32) }
      }

      return s0
    }

    function peg$parseYear () {
      let s0, s1, s2, s3, s4, s5

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$currPos
      s2 = peg$parseDigit()
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigit()
        if (s3 !== peg$FAILED) {
          s4 = peg$parseDigit()
          if (s4 !== peg$FAILED) {
            s5 = peg$parseDigit()
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5]
              s1 = s2
            } else {
              peg$currPos = s1
              s1 = peg$FAILED
            }
          } else {
            peg$currPos = s1
            s1 = peg$FAILED
          }
        } else {
          peg$currPos = s1
          s1 = peg$FAILED
        }
      } else {
        peg$currPos = s1
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f26(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e33) }
      }

      return s0
    }

    function peg$parseMonth () {
      let s0, s1, s2, s3

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$currPos
      s2 = peg$parseDigit()
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigit()
        if (s3 === peg$FAILED) {
          s3 = null
        }
        s2 = [s2, s3]
        s1 = s2
      } else {
        peg$currPos = s1
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f27(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e34) }
      }

      return s0
    }

    function peg$parseDay () {
      let s0, s1, s2, s3

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$currPos
      s2 = peg$parseDigit()
      if (s2 !== peg$FAILED) {
        s3 = peg$parseDigit()
        if (s3 === peg$FAILED) {
          s3 = null
        }
        s2 = [s2, s3]
        s1 = s2
      } else {
        peg$currPos = s1
        s1 = peg$FAILED
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0
        s1 = peg$f28(s1)
      }
      s0 = s1
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e35) }
      }

      return s0
    }

    function peg$parseDate () {
      let s0, s1, s2, s3, s4, s5

      peg$silentFails++
      s0 = peg$currPos
      s1 = peg$parseYear()
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDateSplitter()
        if (s2 !== peg$FAILED) {
          s3 = peg$parseMonth()
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDateSplitter()
            if (s4 !== peg$FAILED) {
              s5 = peg$parseDay()
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0
                s0 = peg$f29(s1, s3, s5)
              } else {
                peg$currPos = s0
                s0 = peg$FAILED
              }
            } else {
              peg$currPos = s0
              s0 = peg$FAILED
            }
          } else {
            peg$currPos = s0
            s0 = peg$FAILED
          }
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e36) }
      }

      return s0
    }

    function peg$parseDateSplitter () {
      let s0

      if (peg$r2.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e37) }
      }

      return s0
    }

    function peg$parsesp () {
      let s0, s1

      s0 = []
      s1 = peg$parseWhiteSpace()
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1)
          s1 = peg$parseWhiteSpace()
        }
      } else {
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parse_ () {
      let s0, s1, s2, s3, s4

      s0 = peg$currPos
      s1 = []
      s2 = peg$parseWhiteSpace()
      while (s2 !== peg$FAILED) {
        s1.push(s2)
        s2 = peg$parseWhiteSpace()
      }
      s2 = []
      s3 = peg$parseLineTerminator()
      while (s3 !== peg$FAILED) {
        s2.push(s3)
        s3 = peg$parseLineTerminator()
      }
      s3 = []
      s4 = peg$parseWhiteSpace()
      while (s4 !== peg$FAILED) {
        s3.push(s4)
        s4 = peg$parseWhiteSpace()
      }
      s1 = [s1, s2, s3]
      s0 = s1

      return s0
    }

    function peg$parseSourceCharacter () {
      let s0

      if (input.length > peg$currPos) {
        s0 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e2) }
      }

      return s0
    }

    function peg$parseZs () {
      let s0

      if (peg$r3.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e38) }
      }

      return s0
    }

    function peg$parseWhiteSpace () {
      let s0, s1

      peg$silentFails++
      if (input.charCodeAt(peg$currPos) === 9) {
        s0 = peg$c18
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e40) }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 11) {
          s0 = peg$c19
          peg$currPos++
        } else {
          s0 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e41) }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 12) {
            s0 = peg$c20
            peg$currPos++
          } else {
            s0 = peg$FAILED
            if (peg$silentFails === 0) { peg$fail(peg$e42) }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 32) {
              s0 = peg$c21
              peg$currPos++
            } else {
              s0 = peg$FAILED
              if (peg$silentFails === 0) { peg$fail(peg$e43) }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 160) {
                s0 = peg$c22
                peg$currPos++
              } else {
                s0 = peg$FAILED
                if (peg$silentFails === 0) { peg$fail(peg$e44) }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 65279) {
                  s0 = peg$c23
                  peg$currPos++
                } else {
                  s0 = peg$FAILED
                  if (peg$silentFails === 0) { peg$fail(peg$e45) }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseZs()
                }
              }
            }
          }
        }
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e39) }
      }

      return s0
    }

    function peg$parseLineTerminator () {
      let s0

      if (peg$r4.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos)
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e46) }
      }

      return s0
    }

    function peg$parseLineTerminatorSequence () {
      let s0, s1

      peg$silentFails++
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c24
        peg$currPos++
      } else {
        s0 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e48) }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c25) {
          s0 = peg$c25
          peg$currPos += 2
        } else {
          s0 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e49) }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c26
            peg$currPos++
          } else {
            s0 = peg$FAILED
            if (peg$silentFails === 0) { peg$fail(peg$e50) }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c27
              peg$currPos++
            } else {
              s0 = peg$FAILED
              if (peg$silentFails === 0) { peg$fail(peg$e51) }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c28
                peg$currPos++
              } else {
                s0 = peg$FAILED
                if (peg$silentFails === 0) { peg$fail(peg$e52) }
              }
            }
          }
        }
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e47) }
      }

      return s0
    }

    function peg$parseComment () {
      let s0, s1

      peg$silentFails++
      s0 = peg$parseMultiLineComment()
      if (s0 === peg$FAILED) {
        s0 = peg$parseSingleLineComment()
      }
      peg$silentFails--
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e53) }
      }

      return s0
    }

    function peg$parseMultiLineComment () {
      let s0, s1, s2, s3, s4, s5

      s0 = peg$currPos
      if (input.substr(peg$currPos, 2) === peg$c29) {
        s1 = peg$c29
        peg$currPos += 2
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e54) }
      }
      if (s1 !== peg$FAILED) {
        s2 = []
        s3 = peg$currPos
        s4 = peg$currPos
        peg$silentFails++
        if (input.substr(peg$currPos, 2) === peg$c30) {
          s5 = peg$c30
          peg$currPos += 2
        } else {
          s5 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e55) }
        }
        peg$silentFails--
        if (s5 === peg$FAILED) {
          s4 = undefined
        } else {
          peg$currPos = s4
          s4 = peg$FAILED
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter()
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5]
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        } else {
          peg$currPos = s3
          s3 = peg$FAILED
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3)
          s3 = peg$currPos
          s4 = peg$currPos
          peg$silentFails++
          if (input.substr(peg$currPos, 2) === peg$c30) {
            s5 = peg$c30
            peg$currPos += 2
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) { peg$fail(peg$e55) }
          }
          peg$silentFails--
          if (s5 === peg$FAILED) {
            s4 = undefined
          } else {
            peg$currPos = s4
            s4 = peg$FAILED
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter()
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        }
        if (input.substr(peg$currPos, 2) === peg$c30) {
          s3 = peg$c30
          peg$currPos += 2
        } else {
          s3 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e55) }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3]
          s0 = s1
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseMultiLineCommentNoLineTerminator () {
      let s0, s1, s2, s3, s4, s5

      s0 = peg$currPos
      if (input.substr(peg$currPos, 2) === peg$c29) {
        s1 = peg$c29
        peg$currPos += 2
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e54) }
      }
      if (s1 !== peg$FAILED) {
        s2 = []
        s3 = peg$currPos
        s4 = peg$currPos
        peg$silentFails++
        if (input.substr(peg$currPos, 2) === peg$c30) {
          s5 = peg$c30
          peg$currPos += 2
        } else {
          s5 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e55) }
        }
        if (s5 === peg$FAILED) {
          s5 = peg$parseLineTerminator()
        }
        peg$silentFails--
        if (s5 === peg$FAILED) {
          s4 = undefined
        } else {
          peg$currPos = s4
          s4 = peg$FAILED
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter()
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5]
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        } else {
          peg$currPos = s3
          s3 = peg$FAILED
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3)
          s3 = peg$currPos
          s4 = peg$currPos
          peg$silentFails++
          if (input.substr(peg$currPos, 2) === peg$c30) {
            s5 = peg$c30
            peg$currPos += 2
          } else {
            s5 = peg$FAILED
            if (peg$silentFails === 0) { peg$fail(peg$e55) }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseLineTerminator()
          }
          peg$silentFails--
          if (s5 === peg$FAILED) {
            s4 = undefined
          } else {
            peg$currPos = s4
            s4 = peg$FAILED
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter()
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        }
        if (input.substr(peg$currPos, 2) === peg$c30) {
          s3 = peg$c30
          peg$currPos += 2
        } else {
          s3 = peg$FAILED
          if (peg$silentFails === 0) { peg$fail(peg$e55) }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3]
          s0 = s1
        } else {
          peg$currPos = s0
          s0 = peg$FAILED
        }
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    function peg$parseSingleLineComment () {
      let s0, s1, s2, s3, s4, s5

      s0 = peg$currPos
      if (input.substr(peg$currPos, 2) === peg$c31) {
        s1 = peg$c31
        peg$currPos += 2
      } else {
        s1 = peg$FAILED
        if (peg$silentFails === 0) { peg$fail(peg$e56) }
      }
      if (s1 !== peg$FAILED) {
        s2 = []
        s3 = peg$currPos
        s4 = peg$currPos
        peg$silentFails++
        s5 = peg$parseLineTerminator()
        peg$silentFails--
        if (s5 === peg$FAILED) {
          s4 = undefined
        } else {
          peg$currPos = s4
          s4 = peg$FAILED
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseSourceCharacter()
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5]
            s3 = s4
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        } else {
          peg$currPos = s3
          s3 = peg$FAILED
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3)
          s3 = peg$currPos
          s4 = peg$currPos
          peg$silentFails++
          s5 = peg$parseLineTerminator()
          peg$silentFails--
          if (s5 === peg$FAILED) {
            s4 = undefined
          } else {
            peg$currPos = s4
            s4 = peg$FAILED
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSourceCharacter()
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5]
              s3 = s4
            } else {
              peg$currPos = s3
              s3 = peg$FAILED
            }
          } else {
            peg$currPos = s3
            s3 = peg$FAILED
          }
        }
        s1 = [s1, s2]
        s0 = s1
      } else {
        peg$currPos = s0
        s0 = peg$FAILED
      }

      return s0
    }

    peg$result = peg$startRuleFunction()

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation())
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      )
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  }
})()
